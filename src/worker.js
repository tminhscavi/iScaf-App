// Enhanced Custom Service Worker
// This will be merged with next-pwa generated code

import { ExpirationPlugin } from 'workbox-expiration';
import {
    cleanupOutdatedCaches,
    precacheAndRoute
} from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import {
    CacheFirst,
    StaleWhileRevalidate
} from 'workbox-strategies';

const CACHE_VERSION = '1.0.1';

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by next-pwa
precacheAndRoute(self.__WB_MANIFEST);

// Enhanced image caching with expiration
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true,
      }),
      {
        cacheKeyWillBeUsed: async ({ request }) => {
          return `${request.url}?version=1`;
        },
      },
    ],
  }),
);

// CSS and JS caching
registerRoute(
  ({ request }) =>
    request.destination === 'style' || request.destination === 'script',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  }),
);

// Enhanced push notification handler with better error handling
self.addEventListener('push', (event) => {
  console.log('[SW] Push Received:', event);

  try {
    const data = event.data?.json() ?? {};
    const title = data.title || 'New Notification';
    const options = {
      body: data.body || 'You have a new message',
      icon: data.icon || '/icons/icon-72z72.png',
      badge: data.badge || '/icons/icon-48x48.png',
      image: data.image,
      tag: data.tag || 'default',
      renotify: data.renotify || false,
      silent: data.silent || false,
      vibrate: data.vibrate || [100, 50, 100],
      timestamp: Date.now(),
      data: {
        url: data.url || '/',
        clickAction: data.clickAction || 'open',
        ...data.data,
      },
      actions: [
        {
          action: 'open',
          title: 'Open',
          icon: 'icons/icon-48x48.png',
        },
        {
          action: 'close',
          title: 'Close',
        },
      ],
    };

    // Add custom actions if provided
    if (data.actions && Array.isArray(data.actions)) {
      options.actions = [...options.actions, ...data.actions];
    }

    event.waitUntil(self.registration.showNotification(title, options));
  } catch (error) {
    console.error('[SW] Push notification error:', error);
    // Fallback notification
    event.waitUntil(
      self.registration.showNotification('Notification', {
        body: 'You have a new message',
        icon: '/icon-192x192.png',
      }),
    );
  }
});

// Enhanced notification click handler
self.addEventListener('notificationclick', (event) => {
  console.log('[SW] Notification click:', event);

  event.notification.close();

  if (event.action === 'close') {
    return;
  }

  const clickAction = event.notification.data?.clickAction || 'open';
  const urlToOpen = event.notification.data?.url || '/';

  event.waitUntil(handleNotificationClick(clickAction, urlToOpen));
});

// Separate function for handling notification clicks
async function handleNotificationClick(action, url) {
  try {
    const clientList = await clients.matchAll({
      type: 'window',
      includeUncontrolled: true,
    });

    // Check if URL is already open
    for (const client of clientList) {
      if (client.url.includes(url) && 'focus' in client) {
        return client.focus();
      }
    }

    // Handle different actions
    switch (action) {
      case 'open':
        if (clients.openWindow) {
          return clients.openWindow(url);
        }
        break;
      default:
        if (clients.openWindow) {
          return clients.openWindow(url);
        }
    }
  } catch (error) {
    console.error('[SW] Notification click handler error:', error);
  }
}

// Enhanced message handling with more commands
self.addEventListener('message', (event) => {
  console.log('[SW] Message received:', event.data);

  if (event.data && event.data.type) {
    switch (event.data.type) {
      case 'SKIP_WAITING':
        self.skipWaiting();
        break;

      case 'GET_VERSION':
        event.ports[0]?.postMessage({ version: CACHE_VERSION });
        break;

      case 'CACHE_URLS':
        event.waitUntil(cacheUrls(event.data.payload));
        break;

      case 'CLEAR_CACHE':
        event.waitUntil(clearCache(event.data.cacheName));
        break;

      case 'GET_CACHE_INFO':
        event.waitUntil(
          getCacheInfo().then((info) => {
            event.ports[0]?.postMessage(info);
          }),
        );
        break;

      case 'PRELOAD_URLS':
        event.waitUntil(preloadUrls(event.data.urls));
        break;
    }
  }
});

// Enhanced cache URLs function with error handling
async function cacheUrls(urls) {
  if (!urls || !Array.isArray(urls)) {
    console.warn('[SW] Invalid URLs provided for caching');
    return;
  }

  try {
    const cache = await caches.open('custom-cache');
    const failedUrls = [];

    for (const url of urls) {
      try {
        await cache.add(url);
      } catch (error) {
        console.warn(`[SW] Failed to cache ${url}:`, error);
        failedUrls.push(url);
      }
    }

    console.log(
      '[SW] URLs cached successfully:',
      urls.filter((url) => !failedUrls.includes(url)),
    );
    if (failedUrls.length > 0) {
      console.warn('[SW] Failed to cache URLs:', failedUrls);
    }
  } catch (error) {
    console.error('[SW] Cache URLs error:', error);
  }
}

// Enhanced clear cache function
async function clearCache(cacheName) {
  try {
    if (cacheName) {
      const deleted = await caches.delete(cacheName);
      console.log(
        `[SW] Cache ${cacheName} ${deleted ? 'cleared' : 'not found'}`,
      );
    } else {
      const cacheNames = await caches.keys();
      const results = await Promise.allSettled(
        cacheNames.map((name) => caches.delete(name)),
      );

      const successful = results.filter(
        (result) => result.status === 'fulfilled',
      ).length;
      console.log(`[SW] ${successful}/${cacheNames.length} caches cleared`);
    }
  } catch (error) {
    console.error('[SW] Clear cache error:', error);
  }
}

// New function to get cache information
async function getCacheInfo() {
  try {
    const cacheNames = await caches.keys();
    const cacheInfo = {};

    for (const cacheName of cacheNames) {
      const cache = await caches.open(cacheName);
      const keys = await cache.keys();
      cacheInfo[cacheName] = {
        entries: keys.length,
        urls: keys.map((req) => req.url),
      };
    }

    return {
      version: CACHE_VERSION,
      caches: cacheInfo,
      totalCaches: cacheNames.length,
    };
  } catch (error) {
    console.error('[SW] Get cache info error:', error);
    return { error: error.message };
  }
}

// Enhanced install event
self.addEventListener('install', (event) => {
  console.log(`[SW] Installing version ${CACHE_VERSION}...`);

  event.waitUntil(
    Promise.all([
      // Pre-cache critical resources
      caches.open('critical-cache').then((cache) => {
        return cache
          .addAll([
            'icons/icon-48x48.png',
            'icons/icon-72x72.png',
            'icons/icon-96x96.png'
          ])
          .catch((error) => {
            console.warn('[SW] Failed to cache critical resources:', error);
          });
      }),
      self.skipWaiting(),
    ]),
  );
});

// Enhanced activate event
self.addEventListener('activate', (event) => {
  console.log(`[SW] Activating version ${CACHE_VERSION}...`);

  event.waitUntil(
    Promise.all([
      clients.claim(),
      // Clean up old version caches
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames.map((cacheName) => {
            if (cacheName.includes('v') && !cacheName.includes(CACHE_VERSION)) {
              console.log('[SW] Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          }),
        );
      }),
    ]).then(() => {
      console.log('[SW] Clients claimed and old caches cleaned');
    }),
  );
});

// Handle background sync
self.addEventListener('sync', (event) => {
  console.log('[SW] Background sync:', event.tag);

  if (event.tag === 'api-sync') {
    event.waitUntil(
      // Handle any background sync logic here
      console.log('[SW] Handling API sync...'),
    );
  }
});
